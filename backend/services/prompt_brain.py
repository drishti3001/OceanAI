"""Prompt brain responsible for loading and updating stored prompts."""
from __future__ import annotations

import json
from pathlib import Path
from typing import Dict, List

from backend.models.prompt import Prompt


class PromptBrain:
    """Stores user-defined prompts and exposes helpers to retrieve them."""

    REQUIRED_PROMPT_IDS = {
        "categorize",
        "actions",
        "draft",
        "agent",
    }

    def __init__(self, prompt_path: Path) -> None:
        self._path = prompt_path
        self._prompts: Dict[str, Prompt] = {}
        self._load_prompts()
        self._ensure_required_prompts_exist()

    # ---------------------------------------------------------
    # LOAD + SAVE
    # ---------------------------------------------------------
    def _load_prompts(self) -> None:
        """Load prompts from disk into memory, robustly handling missing/empty files."""
        payload = {"prompts": []}
        
        if not self._path.exists():
            # If the file doesn't exist, create it with a basic structure
            self._path.write_text(json.dumps(payload, indent=2), encoding="utf-8")
        else:
            try:
                content = self._path.read_text(encoding="utf-8").strip()
                if content:
                    payload = json.loads(content)
            except json.JSONDecodeError as e:
                print(f"WARNING: Corrupted prompts.json file. Error: {e}. Loading empty state.")
            
        # Ensure payload is a dictionary and has the 'prompts' key before loading
        if not isinstance(payload, dict):
            payload = {"prompts": []}

        self._prompts = {
            item["id"]: Prompt.from_dict(item)
            for item in payload.get("prompts", [])
        }

    def _persist(self) -> None:
        """Persist current prompts to disk."""
        data = {"prompts": [prompt.to_dict() for prompt in self._prompts.values()]}
        with self._path.open("w", encoding="utf-8") as handle:
            json.dump(data, handle, indent=2)

    # ---------------------------------------------------------
    # ENSURE DEFAULT PROMPTS EXIST
    # ---------------------------------------------------------
    def _ensure_required_prompts_exist(self) -> None:
        """Ensure categorization, actions, draft, and agent prompts exist."""
        defaults = {
            "categorize": (
                "Read the email body and subject:\n"
                "{email_body}\n\nSubject: {subject}\n\n"
                "Categorize this email into one of these categories ONLY:\n"
                "important, newsletter, spam, to-do, meeting, follow-up, personal, other.\n"
                "Return only the category name."
            ),
            "actions": (
                "Extract clear action items from this email:\n{email_body}\n\n"
                "Return STRICT JSON list format:\n"
                "[ {\"task\": \"...\", \"deadline\": \"...\"} ]\n"
                "If there are no actions, return an empty list []."
            ),
            "draft": (
                "You are an AI assistant writing an email draft.\n"
                "Email body:\n{email_body}\n\n"
                "Subject: {subject}\n"
                "Persona: {persona}\n"
                "{instructions}\n\n"
                "Write a polished, natural reply.\n"
                "Include a subject line, clear body text, and a signature.\n"
                "Do NOT send the email; only prepare the draft."
            ),
            "agent": (
                "You are a specialized analytical Email Agent. Your primary goal is to provide precise, data-driven answers based ONLY on the provided INBOX CONTEXT.\n\nInstructions:\n1. STRICTLY analyze the provided list of emails to answer the User Query.\n2. When asked for counts, totals, or summaries, provide accurate, specific figures.\n3. The email list is provided in the {emails} variable.\n\nINBOX CONTEXT:\n{emails}\n\nUSER QUERY: {query_type}"
            ),
        }

        changed = False

        for prompt_id in self.REQUIRED_PROMPT_IDS:
            if prompt_id not in self._prompts:
                self._prompts[prompt_id] = Prompt(
                    id=prompt_id,
                    name=f"{prompt_id.capitalize()} Prompt",
                    description=f"Default autogenerated {prompt_id} prompt.",
                    template=defaults[prompt_id],
                )
                changed = True

        if changed:
            self._persist()

    # ---------------------------------------------------------
    # ACCESSORS
    # ---------------------------------------------------------
    def list_prompts(self) -> List[Prompt]:
        """Return all prompts."""
        return list(self._prompts.values())

    def get_template(self, prompt_id: str) -> str:
        """Return the raw template text for a given prompt id."""
        if prompt_id not in self._prompts:
            raise KeyError(f"Prompt '{prompt_id}' not found.")
        return self._prompts[prompt_id].template.strip()

    # ---------------------------------------------------------
    # UPSERT
    # ---------------------------------------------------------
    def upsert_prompt(self, payload: dict) -> Prompt:
        """Update an existing prompt or insert a new one."""
        prompt = Prompt.from_dict(payload)
        self._prompts[prompt.id] = prompt
        self._persist()
        return prompt

    # ---------------------------------------------------------
    # DELETE PROMPT (NEW FUNCTIONALITY)
    # ---------------------------------------------------------
    def delete_prompt(self, prompt_id: str) -> bool:
        """
        Removes a prompt by ID from memory and persists the change.
        Returns True if the prompt was found and deleted, False otherwise.
        """
        if prompt_id in self._prompts:
            del self._prompts[prompt_id]
            self._persist()
            return True
        return False